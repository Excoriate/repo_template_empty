# Initial Context Engineering: {{repository_name}}

> **üí° Context Engineering Note:** This document provides comprehensive repository context for AI assistants, AI Agents, and Developers/Maintainers using proven context engineering methodologies. As highlighted by industry leaders in 2025, context engineering represents a fundamental shift from experimental AI use to enterprise-grade AI operations, providing 10x better accuracy and 100x fewer production failures compared to traditional "vibe coding" approaches. It serves as the foundation for understanding the complete project landscape and enables generation of detailed architecture, tech stack, reference documentation, and other downstream documents.

## What is Context Engineering?

Context engineering has emerged as the dominant methodology in AI development, representing a paradigm shift from simple prompt crafting to comprehensive information architecture design. As noted by [Analytics India Magazine](https://analyticsindiamag.com/ai-features/context-engineering-is-the-new-vibe-coding/), "when LLMs fail, it's not because the model is broken ‚Äî it's because the system around it didn't set it up for success."

### Key Components of Context Engineering

**Information Ecosystem Management:**

- **System Instructions and Role Definitions**: Clear, structured directives that define AI behavior and capabilities
- **Conversation History and Memory Management**: Tracking past interactions to maintain coherence and build upon previous context
- **Relevant Documents and Knowledge Base**: Curated external knowledge injection with proper prioritization and chunking
- **Tool Outputs and API Integration**: Real-time data from external systems integrated seamlessly into context
- **Structured Information Architecture**: Organizing data to fit within token constraints while maximizing relevance

**Systems-Level Approach:**
Unlike prompt engineering's focus on individual interactions, context engineering orchestrates multiple layers of information to create a dynamic, intelligent environment. This approach transforms AI from simple responders into intelligent collaborators capable of understanding nuance, user preferences, and complex workflows.

### Context Engineering vs. Traditional Approaches

| Approach | Focus | Methodology | Outcomes |
|----------|-------|-------------|----------|
| **Prompt Engineering** | Individual instructions | Crafting better prompts | Variable results, limited scalability |
| **Vibe Coding** | Intuitive AI interaction | "Feeling your way" through tasks | Experimental, high failure rate |
| **Context Engineering** | Information ecosystem | Systematic framework design | Enterprise-grade reliability, scalable AI operations |

---

## Table of Contents

- [Initial Context Engineering: {{repository\_name}}](#initial-context-engineering-repository_name)
  - [What is Context Engineering?](#what-is-context-engineering)
    - [Key Components of Context Engineering](#key-components-of-context-engineering)
    - [Context Engineering vs. Traditional Approaches](#context-engineering-vs-traditional-approaches)
  - [Table of Contents](#table-of-contents)
  - [How to use this document?](#how-to-use-this-document)
    - [Context Engineering Implementation Structure](#context-engineering-implementation-structure)
    - [Context Engineering Methodology Applied](#context-engineering-methodology-applied)
    - [AI Assistant Obligations](#ai-assistant-obligations)
  - [Workflow](#workflow)
    - [Initial Context as an Input for PRP](#initial-context-as-an-input-for-prp)
    - [Steps](#steps)
    - [Context Engineering Flow Principles](#context-engineering-flow-principles)
    - [Inputs \& Outputs](#inputs--outputs)
      - [Visual Flow](#visual-flow)
      - [Input Components](#input-components)
      - [Output Generation](#output-generation)
  - [Context Engineering Initial Context](#context-engineering-initial-context)
    - [1. Product, Application, or Tool Description](#1-product-application-or-tool-description)
    - [1.1 GitHub Repository](#11-github-repository)
      - [Output Format](#output-format)
    - [1.2 Application/Tool/Product Name](#12-applicationtoolproduct-name)
      - [Output Format](#output-format-1)
    - [1.3 Primary Purpose (High-Level Description)](#13-primary-purpose-high-level-description)
      - [Output Format](#output-format-2)
    - [2. Features](#2-features)
      - [Output Format](#output-format-3)
    - [3. Architecture \& Design Patterns](#3-architecture--design-patterns)
      - [Output Format](#output-format-4)
    - [4. Implementation Requirements](#4-implementation-requirements)
      - [Output Format](#output-format-5)
    - [5. Tech Stack](#5-tech-stack)
      - [Output Format](#output-format-6)
    - [6. Local Development Setup](#6-local-development-setup)
      - [Output Format](#output-format-7)
    - [7. AI Assistant Guidance](#7-ai-assistant-guidance)
      - [Output Format](#output-format-8)
    - [8. Reference \& Documentation](#8-reference--documentation)
      - [Output Format](#output-format-9)

---

## How to use this document?

This document implements **context engineering best practices** to create comprehensive information ecosystems for AI systems. Each section is designed following proven context engineering methodologies:

### Context Engineering Implementation Structure

- **ü§ñ Hint for the AI Assistant**: Structured context guidance that provides semantic understanding and role definition for AI systems, following context engineering principles of clear instruction architecture
- **‚¨áÔ∏è Outcome from this section**: Explicit outcome tracking that enables AI systems to validate completeness and maintain consistency across context layers. No section can be skipped, and each section must be completed with all the required information identified as outcome.
- **üìã Template Variables**: Standardized placeholders (e.g., `{{repository_name}}`) that enable dynamic context adaptation while maintaining structural integrity

### Context Engineering Methodology Applied

This document leverages key context engineering principles:

1. **Structured Information Architecture**: Each section builds upon previous context to create comprehensive understanding
2. **Tool Integration**: Sections are designed to integrate with external data sources and repository analysis tools
3. **Prioritized Information Flow**: Content is organized to maximize AI comprehension within token constraints
4. **Systematic Validation**: Outcome tracking ensures complete context capture before proceeding

### AI Assistant Obligations

The AI assistant must complete each numbered section following context engineering protocols:

- Maintain consistency with established context patterns
- Validate outcomes against provided [example init-context.md](init-context-example.md) file
- Ensure information architecture supports downstream AI operations
- Apply systematic thinking rather than intuitive "vibe-based" approaches

---

## Workflow

### Initial Context as an Input for PRP

This workflow follows a **context engineering workflow** to assess a first initial context, which's a "vertical slice" of all the neccessary context, and then use that context to create a comprehensive information ecosystem for the AI assistant. This document, once completed, constitutes the most important input for any PRP (Product Requirement Prompt)

### Steps

1. **Context Priming Phase**: User provides initial information through the [helper prompt](init-context-helper-prompt.md) to establish foundational context layers and semantic understanding framework. This [helper prompt](init-context-helper-prompt.md) is a prompt that is used to guide the AI assistant to understand the user's requirements, and complete each section of the [init-context.md](init-context.md) file throughtout an assisted and verified process.
2. **Concrete Context Grounding**: User provides examples to enable pattern recognition and contextual anchoring, supporting the AI's understanding through tangible reference points (following context engineering's emphasis on concrete examples over abstract descriptions)
3. **Structured Context Generation**: The comprehensive initial context is systematically generated in [initial_context.md](../../00_context_engineering/init-context.md) following structured information architecture principles. This document is the most important input for any PRP (Product Requirement Prompt)

### Context Engineering Flow Principles

This process implements key context engineering methodologies:

- **Layered Information Building**: Each step builds upon previous context to create comprehensive understanding. Each section provides key information to specifics PRPs (Product Requirement Prompts) to complete each documentation layer in the [docs](../../../docs/) directory.
- **Concrete Grounding**: Examples in the [examples](../../00_context_engineering/examples/) directory provide essential pattern recognition, guidance, known-patterns and implementation details for AI assistants.
- **Structured Output**: Final context document follows systematic organization for optimal AI consumption.
- **Validation Loops**: Each phase includes outcome verification to ensure context completeness

### Inputs & Outputs

#### Visual Flow

> **üöÄ Context Engineering Dual-Input Architecture**
>
> Following [industry research findings](https://medium.com/@tam.tamanna18/understanding-context-engineering-c7bfeeb41889), this dual-input architecture ensures AI systems receive both conceptual guidance and concrete reference points, enabling **10x better accuracy** compared to traditional prompt-based approaches.
>
> **Visual Input Flow:**
>
> ```
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
> ‚îÇ                    CONTEXT ENGINEERING WORKFLOW                 ‚îÇ
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>                                 ‚îÇ
>                                 ‚ñº
>                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
>                    ‚îÇ       USER INPUTS       ‚îÇ
>                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>                                 ‚îÇ
>         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
>         ‚ñº                       ‚îÇ                       ‚ñº
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
> ‚îÇ  HELPER PROMPT    ‚îÇ           ‚îÇ           ‚îÇ    EXAMPLES       ‚îÇ
> ‚îÇ  (Required)       ‚îÇ           ‚îÇ           ‚îÇ   (Optional)      ‚îÇ
> ‚îÇ                   ‚îÇ           ‚îÇ           ‚îÇ                   ‚îÇ
> ‚îÇ ‚Ä¢ Repository info ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Code samples    ‚îÇ
> ‚îÇ ‚Ä¢ Tech stack      ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Config files   ‚îÇ
> ‚îÇ ‚Ä¢ Requirements    ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Links/URLs      ‚îÇ
> ‚îÇ ‚Ä¢ Architecture    ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Documentation  ‚îÇ
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>         ‚îÇ                       ‚îÇ                       ‚îÇ
>         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>                                 ‚ñº
>                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
>                    ‚îÇ    AI ASSISTANT         ‚îÇ
>                    ‚îÇ    PROCESSES INPUTS     ‚îÇ
>                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>                                 ‚îÇ
>                                 ‚ñº
>                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
>                    ‚îÇ       GENERATES         ‚îÇ
>                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
>                                 ‚îÇ
>         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
>         ‚ñº                       ‚îÇ                       ‚ñº
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
> ‚îÇ  init-context.md  ‚îÇ           ‚îÇ           ‚îÇ  examples/        ‚îÇ
> ‚îÇ                   ‚îÇ           ‚îÇ           ‚îÇ  directory        ‚îÇ
> ‚îÇ ‚Ä¢ Complete context‚îÇ           ‚îÇ           ‚îÇ                   ‚îÇ
> ‚îÇ ‚Ä¢ PRP-ready       ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Refined examples‚îÇ
> ‚îÇ ‚Ä¢ All sections    ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Generated files ‚îÇ
> ‚îÇ ‚Ä¢ Template vars   ‚îÇ           ‚îÇ           ‚îÇ ‚Ä¢ Reference docs  ‚îÇ
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
> ```
>

#### Input Components

- ‚úÖ **Helper Prompt (Required):** User answers guided questions from [helper prompt](init-context-helper-prompt.md) to provide systematic project information
- ‚úÖ **Examples (Optional):** User provides example files, code samples, documentation, or links in the [examples directory](../../00_context_engineering/examples) for AI reference and pattern recognition

#### Output Generation

- üìÑ **init-context.md:** Complete [initial context](../../00_context_engineering/init_context.md) document ready for PRP (Product Requirement Prompt) usage
- üìÅ **examples/ directory:** Refined [examples](../../00_context_engineering/examples/), generated reference files, and processed documentation from user inputs

---

## Context Engineering Initial Context

### 1. Product, Application, or Tool Description

### 1.1 GitHub Repository

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üîç ANALYZE ‚Üí Extract repository info from user prompt
> 2. üìÇ CATEGORIZE ‚Üí Separate user-specified vs. auto-inferred settings  
> 3. üìä GENERATE TABLE ‚Üí Create summary table with configurable settings
> 4. ‚öôÔ∏è CREATE YAML ‚Üí Generate detailed configuration with comments
> 5. ‚úÖ VALIDATE ‚Üí Check syntax and completeness
> 6. üì§ PRESENT ‚Üí Output in mandatory structure format
> ```
>
> **üîß Detailed Steps:**
>
> - üìç Analyze the repository location from user's helper prompt (default: `github.com/Excoriate/{{repository_name}}`)
> - üè∑Ô∏è Extract repository metadata (name, description, tech stack)
> - üóÇÔ∏è Categorize settings as user-specified vs. auto-inferred based on analysis
> - üìã Generate simplified summary table and detailed YAML configuration
> - üìñ Reference [settings.yaml](../../../.github/settings.yml) for complete configuration structure
>
> **üîÑ Template Variable Handling:**
>
> - ‚úèÔ∏è Replace `{{repository_name}}` with actual repository name from user input
> - üìù Replace `{{repository_description}}` with actual description from analysis
> - üèóÔ∏è Keep template variables in YAML only when showing configuration structure/examples
> - üíØ Use actual values in the summary table output
>
> **‚úÖ Validation Requirements:**
>
> - üîç Verify repository exists and is accessible (if analyzing existing repo)
> - ‚öñÔ∏è Check for obvious inconsistencies between stated purpose and detected tech stack
> - üìã Validate YAML syntax before presenting configuration
> - üîß Ensure all required fields have values (use defaults when user input incomplete)
> - üìö Cross-reference against settings.yml schema for completeness
>
> **üö® Error Handling & Fallback Strategies:**
>
> - **‚ùå Missing Repository:** If repository doesn't exist or isn't accessible, proceed with template structure using provided information
> - **‚ö†Ô∏è Incomplete Information:** Use organization defaults (Excoriate standards) for missing user specifications
> - **üîß Tech Stack Detection Failure:** Request clarification or use "general" labels and minimal CI requirements
> - **‚ùå Invalid Input:** Politely request correction while providing helpful examples of expected format
> - **‚ö° Conflicting Requirements:** Prioritize security and best practices, note conflicts in output

> [!NOTE]
> **‚¨áÔ∏è Expected Outcomes:**
>
> - ‚òëÔ∏è Git Repository Location: `github.com/Excoriate/{{repository_name}}`
> - ‚òëÔ∏è GitHub Repository Settings configuration matching requirements from settings.yaml

#### Output Format

**MANDATORY STRUCTURE - Present in this exact order:**

1. **Repository Summary Table:**

| GitHub Repository | Description | Configurable Settings |
|------------------|-------------|----------------------|
| `{{repository_name}}` | `{{repository_description}}` | **User-Specified:**<br>- Repository name and description<br>- Technology-specific topics<br>- Team access permissions<br>- Branch protection requirements<br><br>**Auto-Inferred:**<br>- Labels based on tech stack<br>- CI/CD status checks<br>- Security configurations<br>- Best practice defaults |

**Example:**
| GitHub Repository | Description | Configurable Settings |
|------------------|-------------|----------------------|
| `cloudcost-cli` | A powerful CLI tool for AWS cost optimization and resource rightsizing | **User-Specified:**<br>- Repository name: cloudcost-cli<br>- Technology topics: ["cli", "aws", "cost-optimization"]<br>- Team access: maintainers (admin), contributors (push)<br>- Branch protection: require 1 reviewer<br><br>**Auto-Inferred:**<br>- Labels: "go", "terraform", "cli-tool"<br>- CI/CD: ["ci/test", "ci/build", "ci/lint"]<br>- Security: dependabot, code scanning<br>- Best practices: branch protection, required reviews |

2. **Complete GitHub Repository Settings Configuration:**

*Note: Replace template variables `{{variable}}` with actual analyzed values. Variables with `:-default` show fallback values when analysis is incomplete.*

```yml
# Core Repository Configuration (User-Specified + Auto-Inferred)
repository:
  name: {{repository_name}}                    # REPLACE: Actual repository name
  description: {{repository_description}}      # REPLACE: Actual description from analysis
  topics: {{tech_stack_topics}}               # REPLACE: Auto-inferred from primary language & frameworks
                                               # Example: ["typescript", "react", "nodejs"]

# Team Access Configuration (User-Specified or Default Best Practices)
teams:
  - name: maintainers
    permission: admin
  - name: contributors  
    permission: push

# Technology-Specific Labels (Auto-Inferred from Tech Stack)
labels:
  - name: {{primary_language}}                # REPLACE: Detected primary language
    color: "{{language_color}}"               # REPLACE: Standard color for language
    description: "{{primary_language}} related changes"
  - name: {{framework_name}}                  # REPLACE: Detected framework if applicable
    color: "{{framework_color}}"              # REPLACE: Framework-specific color
    description: "{{framework_name}} specific functionality"

# Branch Protection (User Requirements + Security Best Practices)
branches:
  - name: main
    protection:
      required_pull_request_reviews:
        required_approving_review_count: {{min_reviewers:-1}}      # DEFAULT: 1 reviewer minimum
        require_code_owner_reviews: {{require_codeowners:-true}}   # DEFAULT: true
      required_status_checks:
        contexts: {{ci_status_checks}}                             # REPLACE: Auto-inferred from CI/CD workflow
                                                                   # Example: ["ci/lint", "ci/test", "ci/build"]
      restrictions:
        users: [{{repository_owner:-"Excoriate"}}]                # DEFAULT: "Excoriate"
```

Entire [settings.yml](../../../.github/settings.yml) file is present on this repo (on this path `.github/settings.yml`), and is modified according to the user's requirements.

**Example Complete Configuration:**
```yml
# Core Repository Configuration
repository:
  name: cloudcost-cli
  description: "A powerful CLI tool for AWS cost optimization and resource rightsizing"
  topics: ["go", "cli", "aws", "cost-optimization", "devops"]

# Team Access Configuration
teams:
  - name: maintainers
    permission: admin
  - name: contributors  
    permission: push

# Technology-Specific Labels
labels:
  - name: go
    color: "00ADD8"
    description: "Go language related changes"
  - name: cli
    color: "0366d6"
    description: "Command-line interface functionality"

# Branch Protection
branches:
  - name: main
    protection:
      required_pull_request_reviews:
        required_approving_review_count: 1
        require_code_owner_reviews: true
      required_status_checks:
        contexts: ["ci/test", "ci/build", "ci/lint"]
      restrictions:
        users: ["Excoriate"]
```

### 1.2 Application/Tool/Product Name

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```text
> 1. üîç ANALYZE ‚Üí Extract product name from repository and user input
> 2. ‚úèÔ∏è STANDARDIZE ‚Üí Convert to proper product naming format (technical and display)
> 3. üîç VERIFY ‚Üí Ensure consistency with repository's canonical name
> 4. üìù DOCUMENT ‚Üí Record technical name (for env vars, configs) and display name (for docs)
> 5. ‚úÖ VALIDATE ‚Üí Check alignment with user specifications
> 6. üì§ PRESENT ‚Üí Output in standardized format
> ```
>
> **üîß Detailed Steps:**
>
> - üìù Use the exact repository name as the **Technical Name** (for environment variable prefixes, config keys, file names)
> - üîç Ensure consistency with the GitHub repository's canonical name
> - üè∑Ô∏è Only deviate if explicitly specified by the product manager or stakeholder
> - üìå Create **Display Name** by converting technical names to proper title case for documentation
> - üîÑ Maintain technical accuracy while improving readability
> - üìù Create comprehensive product summary (2-3 paragraphs) as product manager would describe to stakeholders
>
> **üîÑ Template Variable Handling:**
>
> - ‚úèÔ∏è Replace `{{repository_name}}` with actual repository name
> - üìù Replace `{{repository_description}}` with actual description from analysis
> - üèóÔ∏è Convert technical naming to **Display Name** for documentation (e.g., "ai-assistant-template" ‚Üí "AI Assistant Template")
>
> **‚úÖ Validation Requirements:**
>
> - üîç Verify Technical Name consistency across repository metadata
> - ‚öñÔ∏è Check for conflicts between technical and display names
> - üìã Ensure Technical Name follows organization naming conventions (for env vars, configs)
> - üîß Validate that Display Name clearly represents the product for documentation
>
> **üö® Error Handling & Fallback Strategies:**
>
> - **‚ùå Missing Product Name:** Use repository name as fallback with proper formatting
> - **‚ö†Ô∏è Unclear Repository Purpose:** Extract intent from README, package.json, or repository description
> - **üîß Inconsistent Naming:** Prioritize user-specified names over auto-detected ones
> - **‚ùå Invalid Characters:** Clean and standardize name while preserving meaning
> - **‚ö° Multiple Naming Conventions:** Use the most descriptive and user-friendly version

#### Output Format

**MANDATORY STRUCTURE - Present in this exact order:**

1. **Product Identification Summary:**

| Product Name | Display Name | Description |
|--------------|--------------|-------------|
| `{{repository_name}}` | `{{display_name}}` | `{{repository_description}}` |

2. **Product Summary:**

(A comprehensive, complete and descriptive overview of the product, described as a product manager would describe it to a stakeholder. 2-3 paragraphs)
Example:

```text
CloudCost CLI is a powerful command-line interface (CLI) tool designed to help cloud engineers and DevOps teams streamline their Amazon Web Services infrastructure management. By providing intelligent cost analysis, resource rightsizing recommendations, and automated optimization strategies, this tool transforms complex cloud resource management into a simple, actionable process.

The CLI leverages advanced algorithmic analysis to scan existing AWS environments, identifying underutilized or overprovisioned EC2 instances, RDS databases, and EBS volumes. Engineers can quickly generate comprehensive reports that highlight potential cost savings, recommend precise resource adjustments, and provide clear migration or downsizing strategies. With built-in safety checks and preview modes, teams can confidently optimize their cloud infrastructure without risking service disruptions.

By combining real-time performance metrics, historical usage patterns, and machine learning-driven insights, CloudCost CLI empowers organizations to reduce cloud spending, improve operational efficiency, and maintain optimal infrastructure performance. Whether managing small startup environments or complex enterprise deployments, this tool provides a user-friendly, data-driven approach to cloud resource management.
```

3. **Complete Product Definition:**

| Field | Value |
|-------|-------|
| **Technical Name** | `{{repository_name}}` |
| **Display Name** | `{{display_name}}` |
| **Description** | `{{repository_description}}` |
| **Other Details** | `{{other_details}}` |

### 1.3 Primary Purpose (High-Level Description)

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üéØ IDENTIFY ‚Üí What specific problem does this solve?
> 2. üìù CLARIFY ‚Üí Explain the problem in simple, jargon-free terms
> 3. üí° ARTICULATE ‚Üí Define the unique value this solution provides
> 4. ‚úÖ VALIDATE ‚Üí Ensure clarity for non-technical stakeholders
> 5. üì§ PRESENT ‚Üí Output in clear, concise format
> ```
>
> **üîß Detailed Steps:**
>
> - üéØ Identify the core problem being solved (what pain point or challenge?)
> - üìù Explain this problem using everyday language, avoiding technical jargon
> - üí° Articulate the specific value this solution delivers (what benefit or outcome?)
> - üîç Ensure the value proposition is unique and differentiated
> - ‚úÖ Test clarity by asking: "Would a non-technical person understand this?"
>
> **‚úÖ Validation Requirements:**
>
> - üîç Problem statement is specific and concrete (not abstract or vague)
> - üìù Language is accessible to non-technical stakeholders
> - üí° Value proposition clearly connects to the identified problem
> - üéØ Focus remains on WHAT problem is solved and WHY it matters

#### Output Format

**Problem Statement:**
(Clearly explain what specific problem or challenge this solves, using everyday language that anyone can understand)

**Value Proposition:**
(Describe the unique benefit or outcome this solution provides, focusing on why it matters to users)

---

### 2. Features

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üîç CATEGORIZE ‚Üí Group capabilities into logical feature areas
> 2. üìù ENUMERATE ‚Üí List specific capabilities within each category
> 3. üéØ PRIORITIZE ‚Üí Distinguish core vs. extended features
> 4. üìÅ REFERENCE ‚Üí Connect to concrete examples when available
> 5. üì§ PRESENT ‚Üí Output in structured, scannable format
> ```
>
> **üîß Detailed Steps:**
>
> - üóÇÔ∏è Group related capabilities into 3-5 logical feature categories
> - üë• Identify target users/roles for each feature category (e.g., developers, administrators, end-users)
> - üìã List 3-6 specific capabilities per category with clear descriptions
> - üìñ Define 1-2 primary use cases per category showing real-world usage scenarios
> - üéØ Identify which features are core (essential) vs. extended (nice-to-have)
> - üìä Specify measurable success indicators for each feature category
> - üìÅ Reference concrete examples from repository or examples/ directory when available
> - üîç Focus on what users can accomplish, not how it's implemented
>
> **‚úÖ Validation Requirements:**
>
> - üóÇÔ∏è Feature categories are distinct and logical
> - üìù Each capability is specific and actionable (not vague)
> - üéØ Core features are clearly distinguished from extended features
> - üìã Descriptions focus on user outcomes, not technical implementation
> - üë• Each feature category has identified target users for PRD context
> - üìñ Use cases provide practical scenarios for user story development
> - üìä Success indicators are measurable and specific for acceptance criteria

#### Output Format

**Core Features:**
- **Target Users:** (Who will primarily use these features - roles/personas)
- **Capabilities:** (List essential functionality that defines the solution)
- **Primary Use Cases:** (1-2 key scenarios showing practical usage context)
- **Success Indicators:** (Measurable outcomes that define feature effectiveness)

**Extended Features:**
- **Target Users:** (Who will primarily use these features - roles/personas)
- **Capabilities:** (List additional functionality for enhanced operation)
- **Primary Use Cases:** (1-2 key scenarios showing practical usage context)
- **Success Indicators:** (Measurable outcomes that define feature effectiveness)

---

### 3. Architecture & Design Patterns

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üé® IDENTIFY ‚Üí Design patterns used (Factory, Builder, Observer, etc.)
> 2. üõ†Ô∏è SPECIFY ‚Üí Language-specific patterns (e.g., Go builder, Python decorator)
> 3. üèóÔ∏è MAP ‚Üí Main system components and their responsibilities
> 4. üèõÔ∏è DEFINE ‚Üí Overall software architecture style (Layered, Hexagonal, etc.)
> 5. üìÅ CREATE ‚Üí Project structure organization as ASCII tree
> 6. üîó EXPLAIN ‚Üí How patterns and architecture solve domain problems
> 7. üì§ PRESENT ‚Üí Comprehensive architecture summary
> ```
>
> **üîß Detailed Steps:**
>
> - üé® Identify code-level design patterns actually implemented in the codebase
> - üõ†Ô∏è Document language-specific patterns relevant to the tech stack
> - üèóÔ∏è Map main system components (services, modules, layers) and responsibilities
> - üèõÔ∏è Define overall software architecture style and organizational approach
> - üìÅ Create ASCII representation of recommended project structure for organizing source code
> - üîó Explain rationale for architectural decisions and pattern choices
> - üìã Show how components interact and patterns solve specific problems
>
> **‚úÖ Validation Requirements:**
>
> - üé® Only include patterns that are actually implemented
> - üõ†Ô∏è Language-specific patterns match the technology stack
> - üèóÔ∏è Components have distinct, clear responsibilities
> - üèõÔ∏è Architecture style aligns with project complexity and requirements
> - üìÅ Project structure reflects architectural decisions and component organization

#### Output Format

**Design Patterns Applied:**
(List specific design patterns used in the codebase with concrete implementation examples and location references)

**Software Architecture Style:**
(Define the overall architectural approach with clear justification: Layered, Hexagonal, Clean Architecture, Microservices, etc. Include visual representation using ASCII diagrams or mermaid for complex architectures)

**Main System Components:**
(Identify primary software modules, their specific responsibilities, and inter-component relationships. Use ASCII diagrams to show component hierarchy and interactions)

**Recommended Project Structure:**
(Present technically justified directory organization that aligns with chosen architecture patterns and reflects component separation principles)

```
(ASCII tree representation of recommended source code organization reflecting architectural decisions)
project-name/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/          # Core application components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/           # Essential business logic components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shared/         # Reusable utility components
‚îÇ   ‚îú‚îÄ‚îÄ services/           # External service integrations
‚îÇ   ‚îú‚îÄ‚îÄ utils/              # Helper functions and utilities
‚îÇ   ‚îú‚îÄ‚îÄ config/             # Configuration files and constants
‚îÇ   ‚îî‚îÄ‚îÄ main.ext            # Application entry point
‚îú‚îÄ‚îÄ tests/                  # Test files mirroring src structure
‚îú‚îÄ‚îÄ docs/                   # Documentation
‚îú‚îÄ‚îÄ scripts/                # Build and development scripts
‚îî‚îÄ‚îÄ examples/               # Usage examples and demos
```

**Architectural Rationale:**
(Provide technical justification for architecture and design pattern choices, explaining how they address specific project requirements and constraints)

**Data Flow Diagram:**
(Visualize how data moves through system components, including input/output flows, transformations, and storage interactions. Use ASCII or mermaid diagrams to show complete data processing pipeline)

---

### 4. Implementation Requirements

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üéØ DEFINE ‚Üí Technical quality attributes and constraints
> 2. üìà SPECIFY ‚Üí Performance benchmarks and scalability targets
> 3. üîí IDENTIFY ‚Üí Security constraints and compliance requirements
> 4. üîó MAP ‚Üí Integration specifications and protocols
> 5. üõ†Ô∏è DOCUMENT ‚Üí Development and deployment constraints
> 6. üì§ PRESENT ‚Üí Implementation-focused requirements summary
> ```
>
> **üîß Detailed Steps:**
>
> - üéØ Define technical quality attributes (maintainability, testability, modularity)
> - üìà Specify measurable performance benchmarks and scalability targets
> - üîí Identify security constraints, compliance needs, and regulatory requirements
> - üîó Document integration protocols, API specifications, and data exchange formats
> - üõ†Ô∏è Specify development environment constraints and deployment requirements
> - üö´ Avoid duplicating feature capabilities (covered in section 2)
> - üö´ Avoid duplicating architecture patterns (covered in section 3)
> - üö´ Avoid duplicating technology choices (covered in section 5)
>
> **‚úÖ Validation Requirements:**
>
> - üéØ Quality attributes include measurable acceptance criteria
> - üìà Performance requirements specify concrete metrics and benchmarks
> - üîí Security requirements address specific threats and compliance standards
> - üîó Integration specifications include protocols, formats, and error handling
> - üõ†Ô∏è Implementation constraints are actionable for development teams

#### Output Format

**Quality Attributes:**
(Define technical quality requirements: maintainability, testability, reliability, usability with measurable acceptance criteria)

**Performance & Scalability:**
(Specify concrete performance benchmarks, response times, throughput targets, and scalability requirements with measurable metrics)

**Security & Compliance:**
(Identify security constraints, threat mitigation requirements, compliance standards, and regulatory requirements that constrain implementation)

**Integration Specifications:**
(Define protocols, data formats, API standards, error handling requirements, and external system interaction constraints)

**Development & Deployment Constraints:**
(Specify development environment requirements, deployment constraints, testing requirements, and operational considerations)

---

### 5. Tech Stack

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üîç IDENTIFY ‚Üí Primary programming language and version
> 2. üì¶ MAP ‚Üí Core frameworks and essential libraries
> 3. üõ†Ô∏è LIST ‚Üí Development tools and build systems
> 4. üê≥ SPECIFY ‚Üí Containerization and deployment tools (if applicable)
> 5. ‚òÅÔ∏è DETAIL ‚Üí Cloud platform and infrastructure tools (if applicable)
> 6. üìù JUSTIFY ‚Üí Document rationale for key technology choices
> 7. üì§ PRESENT ‚Üí Organized tech stack summary
> ```
>
> **üîß Detailed Steps:**
>
 > - üîç Identify primary programming language with version requirements
> - üì¶ List core frameworks, libraries, and essential dependencies
> - üõ†Ô∏è Document development tools, package managers, and build tools
> - üê≥ Include containerization, CI/CD, and deployment technologies when used
> - ‚òÅÔ∏è Specify cloud platform and infrastructure tools when applicable
> - üìù Document rationale for major technology choices (why this framework vs alternatives)
> - üö´ Avoid implementation details (covered in section 4)
> - üö´ Avoid architectural patterns (covered in section 3)
>
> **‚úÖ Validation Requirements:**
>
 > - üîç Primary language includes version requirements
> - üì¶ Core technologies are essential to the project
> - üõ†Ô∏è Development tools support the development workflow
> - üê≥ Only include technologies actually used in the project
> - üîó Tech stack aligns with project requirements from sections 1-4
> - ‚öñÔ∏è Technology choices support identified features and architecture patterns
> - üè∑Ô∏è Tech stack topics align with GitHub repository configuration from section 1

#### Output Format

**Primary Language & Version:**
(Main programming language with version requirements)

**Core Technologies:**
(Essential frameworks, libraries, and runtime dependencies)

**Development Environment:**
(Development tools, package managers, build tools, testing frameworks)

**Deployment & Infrastructure:**
(Containerization, CI/CD, cloud platform, infrastructure tools - if applicable)

**Technology Decision Rationale:**
(Explain key technology choices: why this language/framework was selected, what alternatives were considered, and how choices support project requirements)

---

### 6. Local Development Setup

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üîß SETUP ‚Üí Local environment setup procedures
> 2. ‚úÖ VALIDATE ‚Üí Environment validation commands
> 3. üîß CONFIGURE ‚Üí Project-specific configuration
> 4. üåê CONNECT ‚Üí External service setup
> 5. üì§ PRESENT ‚Üí Complete setup guide
> ```
>
> **üîß Detailed Steps:**
>
 > - üîß Provide step-by-step local environment setup procedures and installation commands
> - ‚úÖ Include environment validation commands to verify correct setup
> - üîß Document project-specific configuration and initialization requirements
> - üåê Specify external service connection and authentication setup procedures
> - üîç Include common setup troubleshooting and resolution steps
> - üö´ Avoid duplicating tech stack tools and versions (covered in section 5)
> - üö´ Avoid duplicating technical constraints (covered in section 4)
>
> **‚úÖ Validation Requirements:**
>
 > - üîß Setup procedures are complete with step-by-step commands
> - ‚úÖ Validation commands verify successful environment setup
> - üîß Configuration steps are specific and actionable
> - üåê External service setup includes authentication and connection verification
> - üîç Troubleshooting covers common setup issues with solutions
> - üîó Setup procedures align with tech stack from section 5

#### Output Format

**Setup Procedures:**
(Step-by-step commands for local environment setup and installation)

**Environment Validation:**
(Commands to verify correct setup and troubleshoot common issues)

**Project Configuration:**
(Project-specific configuration steps and initialization requirements)

**External Service Setup:**
(External service connection procedures, authentication setup, and verification commands)

---

### 7. AI Assistant Guidance

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üß† IDENTIFY ‚Üí AI assistant common pitfalls and mistakes
> 2. üéØ SPECIFY ‚Üí Context-specific behavioral guidance
> 3. üîó REFERENCE ‚Üí Integration with technical constraints from section 4
> 4. üì§ PRESENT ‚Üí AI guidance summary
> ```
>
> **üîß Detailed Steps:**
>
 > - üß† Identify specific mistakes, assumptions, and pitfalls AI assistants commonly make in this domain
> - üéØ Provide context-specific behavioral guidance for optimal AI assistant performance
> - üîç Include domain-specific patterns, conventions, and best practices AI should follow
> - ü§ñ Specify user interaction patterns and response preferences for this project context
> - üö´ Avoid duplicating technical constraints (reference section 4 instead)
> - üö´ Avoid duplicating tech stack or setup details (covered in sections 5-6)
>
> **‚úÖ Validation Requirements:**
>
 > - üß† AI pitfalls are specific with concrete examples and prevention strategies
> - üéØ Behavioral guidance is actionable and context-specific
> - üîç Domain patterns include clear implementation examples
> - ü§ñ User interaction guidance improves AI assistant effectiveness
> - üîó References to section 4 for technical constraints are clear and appropriate

#### Output Format

**AI Common Pitfalls:**
(Specific mistakes, assumptions, and errors AI assistants frequently make in this domain with prevention strategies)

**Behavioral Guidance:**
(Context-specific guidance for optimal AI assistant performance and user interaction patterns)

**Domain-Specific Patterns:**
(Project-specific conventions, best practices, and patterns AI assistants should follow)

**Technical Constraints Reference:**
(Reference section 4 for security, compliance, deployment, and technical implementation constraints)

---

### 8. Reference & Documentation

> [!NOTE]
> **ü§ñ Instructions for AI Assistant:**
>
> **üìã Process Flow - Follow these steps in order:**
>
> ```
> 1. üìù COLLECT ‚Üí User-provided documentation and references
> 2. üîß GATHER ‚Üí Tech stack documentation using Context7 and web tools
> 3. üåê RESEARCH ‚Üí Additional authoritative sources and validation
> 4. üìä ORGANIZE ‚Üí Categorize and validate documentation relevance
> 5. üì§ PRESENT ‚Üí Comprehensive reference list with descriptions
> ```
>
> **üîß Detailed Steps:**
>
 > - üìù Document all user-provided links with descriptions and relevance notes
> - üîß **Tech Stack Documentation:** Use Context7 MCP (`resolve-library-id`, `get-library-docs`) for frameworks and libraries from section 5, supplement with web research for official sources
> - üåê **Additional Research:** Search for authoritative sources, GitHub repositories, standards, and community resources using web tools
> - üìä **Organization:** Categorize by type (Official, API, Tutorials, Community, Standards) and validate accessibility and relevance
> - üìã **Documentation:** Include brief descriptions explaining value and relevance of each resource
> - üö´ Avoid outdated, deprecated, or duplicate documentation
> - üö´ Avoid including resources not relevant to the tech stack from section 5
>
> **üîß MCP Server Usage Guidelines:**
>
> - **Context7:** Prioritize for library and framework documentation (React, Node.js, Python packages, etc.)
> - **Web Tools:** Use for official project sites, GitHub repositories, standards bodies, and community resources
> - **Firecrawl:** Employ for deep research on complex topics or comprehensive documentation extraction
> - **Microsoft Docs:** Utilize specifically for Azure, .NET, TypeScript, and Microsoft ecosystem documentation
>
> **‚úÖ Validation Requirements:**
>
 > - üìù All user-provided links are included with context and relevance notes
> - üîß Tech stack documentation aligns with technologies from section 5
> - üåê Additional sources are current, authoritative, and properly validated
> - üìä Documentation is properly categorized with clear relevance explanations
> - ‚úÖ All links are accessible and directly support the project's requirements

#### Output Format

**Official Documentation:**
(Primary documentation sources, official APIs, and authoritative references from Context7 and web research)

**Library & Framework Documentation:**
(Context7-sourced documentation for tech stack components with version-specific guidance and API references)

**Development Resources:**
(Tutorials, guides, best practices, and implementation examples from authoritative sources)

**Community & Tools:**
(Community resources, third-party tools, libraries, and frameworks with relevance scoring)

**Standards & Specifications:**
(Technical standards, RFCs, specifications, and compliance documentation)

**MCP-Enhanced Resources:**
(Comprehensive documentation gathered using Context7, web tools, and other MCP servers with freshness validation)

---
